<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!-->
<html class="no-js">
<!--<![endif]-->

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Timeline example</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="">
</head>

<body>
    <!--[if lt IE 7]>
            <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="#">upgrade your browser</a> to improve your experience.</p>
        <![endif]-->

    <script src="js/raphael.min.js"></script>
    <script src="js/moment.js"></script>
    <script src="data/app-events.js"></script>
    <script>
        class DataEvent {
            constructor(event_id, event_timestamp, event_status) {
                this.event_id = event_id;
                this.timestamp_string = event_timestamp;
                this.timestamp = this.parseTimestamp();
                this.status = event_status;
            }

            parseTimestamp() {
                var format = 'DD.MM.yyyy hh.mm.ss';
                return moment(this.timestamp_string, format);

            }
        }
        ((eventStrings) => {
            window.dataEvents = eventStrings.map(line => {
                [status, timestamp, eventid] = line.split("|");
                return new DataEvent(eventid, timestamp, status);
            });
        })(data);
    </script>
    <script>
        let event_dates = dataEvents.map(ev => { return ev.timestamp.format("YYYY-MM-DD"); });
        let event_date_counts = event_dates.reduce((acc, item) => { 
            if (item in acc) { 
                acc[item] += 1 
            } else { 
                acc[item] = 1 
            } 
            return acc; 
        }, []);
        let unique_dates = Object.keys(event_date_counts).length
        console.log("There are a total of ", unique_dates, "dates in the array");
        // Object.keys(event_date_counts).sort().forEach(edc => {
        //     console.log(edc, " => ", event_date_counts[edc] );
        // });
        var paper = Raphael(10, 50, 800, 600);
        paper.rect(0, 0, 800, 600);

        var graph_base_y = 500;
        var graph_base_x = 100;
        var graph_max_height = 100;
        var graph_gap_normal_x = 10;
        var graph_max_width = 800 - 100 - 100;
        var graph_easy_fit_x = Math.floor(graph_max_width / graph_gap_normal_x);
        var can_fit = (unique_dates < graph_easy_fit_x);
        var fitting_data = groupDates(event_date_counts, graph_easy_fit_x);
        
        var maxFinder = (lord, usurper) => { return (usurper > lord ? usurper : lord); }

        
        function normalizeValues(key_values, max_val = 100, min_val = 0) {
            let current_max = Object.values(key_values).reduce(maxFinder);
            let current_min = Object.values(key_values).map(v => { return (-1 * v); }).reduce(maxFinder);
            let ratio = (max_val - min_val) / (current_max - current_min);
            let normalizedValues = new Map();
            Object.keys(key_values).forEach(key => {
                let val = key_values[key];
                let new_val = max_val - (ratio * val);
                normalizedValues[key] = new_val;
            });
            return normalizedValues;

        }

        function groupDates(key_values, maxGroups) {
            let group_count = Object.keys(key_values).length;
            if (group_count <= maxGroups) {
                return key_values;
            }

            let group_size = Math.ceil(group_count / maxGroups);
            var group_number = 0;
            var grouped = new Map();
            Object.keys(key_values).sort().forEach((key, index) => {
                let group_changed = false;
                if (index % group_size == 0) {
                    group_number += 1;
                    group_changed = true;
                }
                let group_name = ("" + group_number + "-grp").padStart(8, "0");
                grouped[group_name] = (group_changed ? 0 : grouped[group_name]) + key_values[key]
            });
            return grouped;
        }

        if (can_fit) {
            console.log("we can fit all items easily");
        } else {
            console.log("need to make it tighter ", unique_dates, ">", graph_easy_fit_x);
            unique_dates = Object.keys(fitting_data).length;
            can_fit = (unique_dates < graph_easy_fit_x);
            console.log("After grouping: ", unique_dates);
        }
        
        let normalized_data = normalizeValues(fitting_data, graph_max_height);

        if (can_fit) {
            Object.keys(normalized_data).sort().forEach((edc, idx) => {
                let m_x = graph_base_x + (idx * graph_gap_normal_x);
                let m_y = graph_base_y;
                let l_x = m_x;
                let l_y = graph_base_y - normalized_data[edc];
                paper.path(`M${m_x} ${m_y}L${l_x} ${l_y}`);
            });
        }

    </script>
</body>

</html>